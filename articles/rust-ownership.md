
---
title: "[Rust] 所有権理解が曖昧だったので、再度調べ直した"
emoji: "📓"
type: "tech"
topics: ["rust", "初心者", "memo", "学習メモ"]
published: true
---

## 所有権のルール
https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%A8%A9%E8%A6%8F%E5%89%87
以下の3つのルールがある。
1. 各値は、所有者（変数）と対応している
2. 所有者は必ず１つ
3. 所有者がスコープから外れたら、値は破棄される

## 変数スコープ
スコープとは、要素が有効になる範囲のこと。
スコープ内で宣言された変数は、宣言されたスコープ内でのみ有効になる。

### ブロックスコープ内の変数
`{}`で囲まれたブロック内で宣言された変数は、そのブロック内でのみ有効です。
```rust
fn main() {
  { // ブロックスコープ
    let x = 5;
    println!("x: {}", x) // スコープ内なので有効
  }
  println!("x: {}", x) // スコープ外なので無効
}
```

### 関数スコープ内の変数
関数内で宣言された変数は、その関数内でのみ有効になる。
```rust
fn function() {
  let x = 5;
  println!("x: {}", x); // 関数内のため有効
} // ここでxのスコープが終了

fn main() {
  function();
  // println!("x: {}", x); // エラー：変数xはこのスコープでは無効
}
```

## シャドーイング
シャドーイングとは、スコープ内部で宣言した変数名と、スコープ外部で宣言された変数名が同じ場合に、スコープの内部の変数が優先されることを指します。
Rustでは、このシャドーインが有効で、スコープ内部で同じ名前の変数を再度宣言することができます。
```rust
fn function () {
    let x = 5;
    println!("x: {}", x); // xは5

    {
        let x = 10; // シャドーイング エラーにはならない
        println!("x: {}", x); // xは10
    }

    println!("x: {}", x); // xは5
}
```

### 参考
https://en.wikipedia.org/wiki/Variable_shadowing

## 値の束縛
Rustでは、値（リテラルなど）を`let`文を使用することで束縛することができる。
`let`
デフォルトでは、イミュータブルとなる。
```rust
let x = 5
x = 3 // イミュータブルのため、エラーになる
```
`mut`構文を使用することで、ミュータブルになる
```rust
let mut x = 5;
x = 3 // ミュータブルのためエラーにならない
```

### 参考
https://doc.rust-jp.rs/rust-by-example-ja/variable_bindings.html

## ムーブ
Rustでは、値を別の変数に代入すると、所有権が移動します。
これを「ムーブ」と呼びます。
ムーブ後、元の変数はその値を使用できなくなり、使用できなくなった変数を参照しようとすると、コンパイルエラーになります。
これにより、二重解放などのメモリエラーを防ぎます。
ただし、コピートレイトが実装されている型の場合は、代入時にムーブではなくコピーが行われます。

### 変数の代入によるムーブ
#### コピートレイトが実装されている値
整数、浮動小数点数、ブール値などの単純な型は、コピートレイトが実装されています。
これらの値が代入されるとき、元の値はコピーされます。

```rust
let x = 5;
let y = x; // コピーが行われる

println!("x: {}", x); // 問題なく使用できる
println!("y: {}", y);
```

#### コピートレイトが実装されていない値
String型や独自の構造体など、コピートレイトを実装していない値もあります。
これらの値が代入される時は、所有権のムーブする。
```rust
let x = String::from("hello");
let y = x; // ムーブが行われる。

// println!("x: {}", x); // 値がムーブされた後に使用されているため、コンパイルエラーになる。
println!("y: {}", y); // 問題ないく使用できる。
```

### 関数呼び出しによるムーブ
#### コピートレイトが実装されている値
変数代入時と同様に、コピートレイトが実装されている値は、関数に渡されるときにコピーされます。

```rust
fn print_integer(n: i32) {
    /のコピーが関数に渡されるる
    println!("n: {}", n);
}   

fn main() {
    let x = 5;
    print_integer(x); // コピーが行われる

    println!("x: {}", x); // 問題なく使用できる
}
```

#### コピートレイトが実装されていない値
こちらも、変数代入時と同様に、コピートレイトが実装されていない値は、関数に渡されるときに所有権がムーブされます。
```rust
fn print_string(s: String) {
    // sの所有権が関数にムーブされる
    println!("s: {}", s);
} 

fn main() {
    let s = String::from("hello");
    print_string(s); // 所有権が関数にムーブされる

    // println!("s: {}", s); // 所有権がムーブされた後に使用されているため、コンパイルエラーになる
}

```
#### 参考
- https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%A8%A9%E3%81%A8%E9%96%A2%E6%95%B0

## コピー

## クローン
## 借用
## 参照と借用の関係
## 可変参照と不変参照のルール
## ライフタイム
## スライス
## メモリ安全性の保証
## Box<T>とヒープメモリ

## 参考
https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html
https://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/30450c
https://doc.rust-lang.org/beta/rust-by-example/ja/variable_bindings/scope.html
